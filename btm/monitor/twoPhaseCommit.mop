package mop;

import java.io.*;
import java.util.*;
import javax.transaction.RollbackException;
import javax.transaction.Status;
import javax.transaction.Transaction;
import javax.transaction.xa.XAException;
import javax.transaction.xa.XAResource;

import bitronix.tm.twopc.Committer;
import bitronix.tm.twopc.Preparer;
import bitronix.tm.twopc.Rollbacker;
import bitronix.tm.twopc.XAResourceWrapper;

twoPhaseCommit(Transaction tx) {

    Set<XAResource> participants = new HashSet<XAResource>();
    Set<XAResource> prepared = new HashSet<XAResource>();
    Set<XAResource> rolledback = new HashSet<XAResource>();
    Set<XAResource> committed = new HashSet<XAResource>();
    // https://docs.oracle.com/javaee/5/api/javax/transaction/Status.html
    int state = Status.STATUS_NO_TRANSACTION;
    Transaction transaction;

    event addResource after (Transaction tx, XAResource xa):
        execution(* Transaction.enlistResource(XAResource))
        && target(tx)
        && args(xa) {
        if (state == Status.STATUS_NO_TRANSACTION) {
            // state Init -> state Init
            participants.add(xa);
            System.out.println("Add participant");
        } else {
            System.out.println("ERROR: invalid transition!");
        }
    }

    event startTx before (Transaction tx):
        execution(* Transaction.commit())
        && target(tx) {
        if (state == Status.STATUS_NO_TRANSACTION) {
            // state Init -> state SendAndReceivePrepareMsgs
            transaction = tx;
            state = Status.STATUS_PREPARING;
        } else {
            System.out.println("ERROR: invalid transition!");
        }
    }

    event xaPrepareSuccess after (Transaction tx, XAResourceWrapper xar) returning (int result):
        execution(* XAResourceWrapper.prepare(Transaction+, ..))
        && target(xar)
        && args(tx, ..) {
            if (state == Status.STATUS_PREPARING) {
                // state SendAndReceivePrepareMsgs -> state SendAndReceivePrepareMsgs
                prepared.add(xar.getXAResource());
                try {
                    System.out.println(String.format("Participant prepared. " +
                                                     "transaction state: %s, monitor state: %s",
                                                     MopUtils.stateToString(transaction.getStatus()),
                                                     MopUtils.stateToString(state)));
                } catch (Exception e) {}
                if(prepared.size() == participants.size()) {
                    // state SendAndReceivePrepareMsgs -> state SendAndReceiveCommitMsgs
                    state = Status.STATUS_COMMITTING;
                    System.out.println("All participants prepared.");
                }
            } else if (state == Status.STATUS_ROLLING_BACK) {
                // state SendAndReceiveRollbackMsgs -> state SendAndReceiveRollbackMsgs
            } else {
                System.out.println("ERROR: invalid transition!");
            }
    }

    event xaPrepareFailure after (Transaction tx) throwing (XAException e):
        execution(* XAResourceWrapper.prepare(Transaction+, ..))
        && args(tx, ..) {
            if (state == Status.STATUS_PREPARING) {
                // state SendAndReceivePrepareMsgs -> state SendAndReceiveRollbackMsgs
                state = Status.STATUS_ROLLING_BACK;
                System.out.println("participant prepare failed.");
            } else if (state == Status.STATUS_ROLLING_BACK) {
                // state SendAndReceiveRollbackMsgs -> state SendAndReceiveRollbackMsgs
            } else {
                System.out.println("ERROR: invalid transition!");
            }
    }

    event xaRollbackSuccess after (Transaction tx, XAResourceWrapper xar) :
        execution(* XAResourceWrapper.rollback(Transaction+, ..))
        && target(xar)
        && args(tx, ..) {
            if (state == Status.STATUS_ROLLING_BACK) {
                // state SendAndReceiveRollbackMsgs -> state SendAndReceiveRollbackMsgs
                rolledback.add(xar.getXAResource());
                try {
                    System.out.println(String.format("Participant rolledback. " +
                                                     "transaction state: %s, monitor state: %s",
                                                     MopUtils.stateToString(transaction.getStatus()),
                                                     MopUtils.stateToString(state)));
                } catch (Exception e) {}
            } else {
                System.out.println("ERROR: invalid transition!");
            }
    }

    event xaCommitSuccess after (Transaction tx, XAResourceWrapper xar) :
        execution(* XAResourceWrapper.commit(Transaction+, ..))
        && target(xar)
        && args(tx, ..) {
            if (state == Status.STATUS_COMMITTING) {
                // state SendAndReceiveCommitMsgs -> state SendAndReceiveCommitMsgs
                committed.add(xar.getXAResource());
                try {
                    System.out.println(String.format("Participant committed. " +
                                                     "transaction state: %s, monitor state: %s",
                                                      MopUtils.stateToString(transaction.getStatus()),
                                                      MopUtils.stateToString(state)));
                } catch (Exception e) {}
            } else {
                System.out.println(String.format("ERROR: Commit operation is not allowed in the state %s", MopUtils.stateToString(state)));
            }
    }

    event endTx after (Transaction tx):
         execution(* Transaction.commit())
         && target(tx) {
             if (state == Status.STATUS_ROLLING_BACK) {
                 if (rolledback.size() == participants.size()) {
                     state = Status.STATUS_ROLLEDBACK;
                 } else {
                     System.out.println("ERROR: Not all participants rolledback.");
                 }
             } else if (state == Status.STATUS_COMMITTING) {
                 if (committed.size() == participants.size()) {
                     state = Status.STATUS_COMMITTED;
                 } else {
                     System.out.println("ERROR: Not all participants committed.");
                 }
             } else {
                 System.out.println("ERROR: invalid transition!");
             }

             try {
                 System.out.println(String.format("End of transaction. " +
                                                  "transaction state: %s, monitor state: %s",
                                                  MopUtils.stateToString(transaction.getStatus()),
                                                  MopUtils.stateToString(state)));
             } catch (Exception e) {}
    }
}
